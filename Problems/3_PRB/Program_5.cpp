#include <iostream>
using namespace std;

//클래스를 정의하는; 방법(접근지정자 포함)
class ClassName
{
public: //어디서나 접근 가능한 멤버 함수/변수들
	ClassName() {}; // 생성자 : 클래스가 생길 때 호출됨, Parameter및 여러개의 생성자 사용 가능
	~ClassName() {};// 소멸자 : 클래스가 소멸할 때 호출됨, Parameter를 받을 수 없으며, 단 하나만 존재 가능

private: //자신 말고는 아무도 접근할 수 없음

protected: //자신 또는 자신과 상속관계에 있는 클래스만 접근할 수 있음

};
 

//클래스를 상속하여 정의하는 방법 및 상속의 효과(이유, 장점 등)
//            :상속지정자 를 사용하여 상속을 시키면서 정의할 수 있다.
class Derived : public ClassName {};
//클래스를 상속을 시켜서 정의하면 공통적인 부분을 가지고 있는 것들을 모아
//공통적인 부분만 상위클래스로 만들어 코드의 재사용성이 용이해지고
//코드를 상위클래스로 뺴냈으므로 자식클래스의 코드가 간결해 지는 장점이 있으며
//위 장점을 통틀어 유지보수에 이점이 있기 때문에 상속을 사용한다.


//클래스 멤버함수의 오버라이드 방법 및 효과(이유, 장점 등)
class Sample {
public: //부모클래스에 함수가 선언되어있다.
	void SampleFunc() { cout << "Hello!" << endl; };
};

class DerivedSample : Sample {
public:
	void SampleFunc() { cout << "Hello!" << endl; };
	//상속을 받은 자식 클래스에 같은 이름의 함수를 재정의하면
	//재 정의한 기능이 해당 클래스에서만 작동한다.
	//이를 함수의 오버라이드라고 한다.

	//오버라이딩이 필요한 이유는 자식 클래스는 부모의 기능을 상속받지만
	//상속의 특징상 더 구체화 된 자식 클래스는 새로운 기능을 더하거나, 다른 기능이 필요할 수 있다.
	//오버라이딩을 통해 같은 함수를 사용하더라도 클래스마다 사용하는 기능이 각자 필요에 맞게 만들 수 있다.
};


//클래스의 다형성을 이용하는 방법 및 효과(이유, 장점 등)
//클래스의 다형성을 사용하는 방법은 다양하게 있는데
//	정적  다형성
//		함수 오버로딩
//			함수의 Parameter를 다르게 하는 것 으로 다른 역할을 하게 만드는 기능
//			이 기능을 통해 비슷한 기능의 함수들을 전부 다른 이름의 함수로 만들지 않고도
//			Parameter만 달리하여 다른 기능을 할 수 있게 만들어 준다.
// 
//		연산자 오버로딩
//			연산자 오버로딩은 기존의 연산자를 재 정의하여 사용자 정의 클래스로 사용하는 것이다.
//			흔히 볼수 있는 오버로딩으로는 <<, >>는 비트연산자 이지만 cin, cout에서 인자값을 받을 수 있도록 오버로딩하여 사용중이다.
//			연산자 오버로딩을 통해 클래스의 멤버함수로만 작업을 해야 하던 방식에서 연산자를 통해서 작업을 할 수 있게 되며
//			다양한 기능을 간편하게 사용할 수 있게 된다.
//  
//		템플릿
//			템플릿은 대부분 같은 코드를 사용하지만 자료형 차이만으로 함수를 여러개를 생성하는 낭비를 줄여줄 수 있다.
//			즉 사용자가 원하는 자료형을 넣어주면 그에 맞추어 코드를 찍어내는 틀 처럼 사용할 수 있다.
//			이는 클래스에서도 그대로 적용하여 클래스의 멤버 변수를 다양한 자료형으로도 사용할 때 간결한 코드로 사용할 수 있게 해준다.
//	
//	동적 다형성
//		가상 함수(함수 오버라이딩)
//			가상 함수는 몸체가 없는 함수를 부모 클래스에 생성하는 방식으로 만들 수 있다.
class sc {
	virtual void virtualfunc() = 0;
	};
//			이렇게 가상함수를 부모 클래스에서 만들어 두면, 이후메 만들어지는 자식클래스들은 무조건 해당 함수를 정의해야 작동하게 할 수 있다.
//			이런 기능이 필요한 이유는 미리 부모 클래스에서 정적으로 함수를 선언해 둔다면 자식 클래스에서 동적 할당을 통해 클래스를 사용할 때
//			오버라이딩된 기능을 사용하려고 해도, 이미 컴파일 당시에 호출할 함수의 주소를 결정해 버렸기 떄문에 부모의 함수를 호출하게 된다.
//			이를 해결하기 위해서는 부모 클래스에서 함수를 가상 함수로 선언하여 자식 클래스의 멤버함수를 호출할 수 있게 해야한다.


//클래스 상속 시 자식 클래스의 객체에서 부모 클래스의 멤버 변수와 멤버 함수를 접근하는 방법
class SuperClass {
public:
	//virtual 키워드를 이용하여 몸체가 없는 함수를 선언한다.
	virtual void func() = 0;
};

class DerivedClass : SuperClass {
	//자식 클래스에서 가상함수로 선언된 함수를 정의 해준다.
public:
	void func() { cout << "Hello!" << endl; };
};

int main() {
	DerivedClass* DC = new DerivedClass;
	DC->func();
	//동적할당된 자식 클래스에서 함수를 호출할 수 있게 되었다.
}