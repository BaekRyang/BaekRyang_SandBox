=== 전략(Strategy) ===
전략이란 말 그대로 상황에 맞춰 그 상황에 맞는 다른 행동을 취한다는 뜻이다. 예를 들어 내가 중세 시대의 전투에 나간다고 했을 때, 우리 병사들이 칼을 들고 있다면 칼 들고 돌격을 해야 할 것이고, 활을 들고 있다면 멀찍이 거리를 벌리고 화살을 쏴야 할 것이다. 이런 식으로 현재 상황에 따라 '공격'이라는 같은 행위를 취함에도 불구하고 실제 행동은 전혀 달라진다. 이러한 것들을 결정하는 '전략'이라는 객체를 생성하여 현재 상태에 따른 행동을 결정시키는 것이 전략 패턴의 기본적인 골자가 된다.

==== 예시 ====
전략 패턴의 경우 가장 자주 쓰이는 예시가 FPS 게임이다. 아주 간단한 FPS 게임을 제작해본다고 하자. 처음 기획은 이하와 같이 시작하였다.

 * WASD로 플레이어의 움직임을 조작하고, 마우스 좌클릭을 사용하면 공격을 한다.
 * 플레이어는 '칼'과 '권총'이라는 두 개의 무기를 갖고 있다.
  * 칼을 장비할 경우 마우스 좌클릭을 하면 칼을 휘두른다.
  * 총을 장비할 경우 마우스 좌클릭을 하면 총을 발사한다.

이를 각각의 무기를 클래스로 만들고 플레이어가 조종할 수 있게 만든다고 해 보자. 칼과 권총은 둘 다 무기에 속하므로, Weapon이라는 abstract class를 만들고 칼과 권총을 각각 거기에 할당시키면 구현할 수 있다. (편의 상 무기 클래스와 관련된 함수만 구현한다.)
{{{#!syntax csharp
public abstract class Weapon{
    public abstract void attack();
}

public class Knife : Weapon{
    public override void attack(){ /* 칼을 휘두른다. */ }
}

public class Pistol : Weapon{
    public override void attack(){ /* 권총을 쏜다. */ }
}
}}}
이렇게 구현을 성공한 게임 제작자는 그대로 게임을 내지만, 칼이랑 권총밖에 없어 게임이 식상하다는 평가를 받는다. 그래서 제작자는 칼과 권총 외에도 '저격총'이라는 세 번째 무기를 만들기로 한다. 새로 만드는 무기인 만큼 새로운 기능을 넣는데, 저격총은 공격이 색다를 뿐만 아니라 '마우스 우클릭을 하여 줌 인을 할 수 있다' 라는 새로운 기능을 추가하고자 한다.
{{{#!syntax csharp
public abstract class Weapon{
    public abstract void attack();
}

public class Knife : Weapon{
    public override void attack(){ /* 칼을 휘두른다. */ }
}

public class Pistol : Weapon{
    public override void attack(){ /* 권총을 쏜다. */ }
}

public class Snipe : Weapon{
    public override void attack(){ /* 저격총을 쏜다. */ }
    public override void rightclick(){ /* 조준경으로 확대해서 본다. */ }
}
}}}
그렇다면 여기서부터 코드에 문제가 생긴다. 저격총에는 우클릭을 해서 '줌 인'을 할 수 있는 기능이 있는데, 칼과 권총에는 그 기능이 없다. 그래서 Snipe 클래스 안에 rightclick()이라는 함수를 넣긴 넣었는데, 이는 원래 Weapon abstract class에는 없는 기능이다.

이 상황을 어떻게 해결해야 할까?

===== 전략 패턴이 아닌 해결책과 문제점 =====
개발자는 일단 Weapon class 안에 rightclick()을 넣어놓고, 칼과 권총은 어차피 그 기능을 하지 않으므로 더미 함수만 지정해주는 방식을 사용했다.
{{{#!syntax csharp
public abstract class Weapon{
    public abstract void attack();
    public abstract void rightclick();
}

public class Knife : Weapon{
    public override void attack(){ /* 칼을 휘두른다. */ }
    public override void rightclick(){ /* 아무 일도 일어나지 않는다. */ }
}

public class Pistol : Weapon{
    public override void attack(){ /* 권총을 쏜다. */ }
    public override void rightclick(){ /* 아무 일도 일어나지 않는다. */ }
}

public class Snipe : Weapon{
    public override void attack(){ /* 저격총을 쏜다. */ }
    public override void rightclick(){ /* 조준경으로 확대해서 본다. */ }
}
}}}
이 코드 자체는 잘 동작하지만 좋지 못한 코드다. 왜냐하면 지금은 '마우스 우클릭'으로 한정지어 더미 함수를 추가했는데, 먼 훗날 게임을 업데이트하다보니 '이건 샷건인데 R키를 눌러 장전해야 함', '이건 수류탄인데 Q를 꾹 누르고 있으면 투척력이 강해짐' 따위의 온갖 새로운 기능들이 추가될 수도 있다. 그럼 그럴 때마다 abstract class Weapon에는 온갖 함수들이 추가될 것이며, 그 경우 그 기능들을 쓰지 않는 무기는 온갖 더미 함수를 치렁치렁 매달아야 하며 이는 일일이 찾아가 바꿔주기에도 귀찮으며 기능이 많아지면 뭐가 뭔지 모를 스파게티 코드가 되어버리고 만다. 게다가 기존의 Weapon 클래스를 일일이 수정하다가 누락이라도 발생한다면 런타임 에러가 발생하거나, 칼을 들었는데 갑자기 수류탄에서 써야 할 Q버튼의 기능이 칼에서 발생한다든가 하는 버그가 터질 수도 있다.
{{{#!syntax csharp
public abstract class Weapon{
    public abstract void attack();
    public abstract void rightclick();
    public abstract void Rclick();
    public abstract void Qclick();
    public abstract void Eclick();
}

public class Knife : Weapon{
    public override void attack(){ /* 칼을 휘두른다. */ }
    public override void rightclick(){ /* 아무 일도 일어나지 않는다. */ }
    public override void Rclick(){ /* 아무 일도 일어나지 않는다. */ }
    public override void Qclick(){ /* 아무 일도 일어나지 않는다. */ }
    public override void Eclick(){ /* 아무 일도 일어나지 않는다. */ }
    // 아무 기능도 안 쓰는 Knife는 쓰지도 않을 기능이 추가될 때마다 온갖 더미 함수를 뒤집어쓰게 된다.
}
}}}
'그렇다면 우클릭을 사용하는 다른 클래스를 만들어 저격총에만 상속시켜주자' 라고 다른 방식을 생각해보자. 즉 저격총만 우클릭을 사용하고 칼과 권총은 우클릭을 사용하지 않으므로, 저격총에만 우클릭 함수가 존재하는 abstract class를 따로 상속시켜주는 것이다. 이렇게 한다면 추후 어떤 기능이 추가되든 그 기능과 무관한 무기(칼 등)가 더미 함수에 가득찰 일도 없을 것이다.
{{{#!syntax csharp
public abstract class WeaponL{
    public abstract void clickL();
}

public abstract class WeaponR{
    public abstract void clickR();
}

public class Knife : WeaponL{
    public override void clickL(){ /* 칼을 휘두른다. */ }
}

public class Pistol : WeaponL{
    public override void clickL(){ /* 권총을 쏜다. */ }
}

public class Snipe : WeaponL, WeaponR{
    public override void clickL(){ /* 저격총을 쏜다. */ }
    public override void clickR(){ /* 조준경으로 확대해서 본다. */ }
}
}}}
그렇다면 이 코딩은 문제가 없을까? 그렇지 않다.

이렇게 코딩을 해서 게임이 잘 돌아가고 있는데, 이번에는 저격총이 너무 세고 사거리가 길어서 가기도 전에 죽는다는 밸런스 문제가 생겨버렸다고 해 보자. 개발자는 이를 해결하기 위해서 '저격총은 들면 못 움직이게 만들자' 라는 해결책을 내놓았다. 이렇게 하기 위해서는 또 'WeaponWASD'라는 클래스를 하나 더 만들어 상속시켜야 한다.
{{{#!syntax csharp
public abstract class WeaponL{
    public abstract void clickL();
}

public abstract class WeaponR{
    public abstract void clickR();
}

public abstract class WeaponWASD{
    public abstract void WASD();
}

public class Knife : WeaponL, WeaponWASD{
    public override void clickL(){ /* 칼을 휘두른다. */ }
    public override void WASD(){ /* 방향키대로 움직인다. */ }
}

public class Pistol : WeaponL, WeaponWASD{
    public override void clickL(){ /* 권총을 쏜다. */ }
    public override void WASD(){ /* 방향키대로 움직인다. */ }
}

public class Snipe : WeaponL, WeaponR{
    public override void clickL(){ /* 저격총을 쏜다. */ }
    public override void clickR(){ /* 조준경으로 확대해서 본다. */ }
}
}}}
이렇게 추가를 하고 보니, 나중에 무기가 추가될 때도 저격총이 제자리에서 써야 하는 특이한 무기이며 어지간한 무기는 들고 올 때마다 WASD로 이동하면서 쓸 수 있을 텐데, 그러면 새로운 무기를 추가할 때마다 거기에 WASD 클래스를 상속시켜주고 방향키 이동 함수도 전부 다 일일이 구현해줘야 한다. 새로운 기능이 나타나든 기존 기능을 상속시켜주든 일일이 코딩을 복붙해줘야 하므로 재사용성이 떨어진다. 뿐만 아니라 나중에 '플레이어의 속도가 너무 빨라서 줄였습니다' 같은 패치를 내놓을 때, 각 무기에 상속된 WASD()를 일일이 수정해줘야 해서 유지보수도 어려워진다.

그렇다면 코드의 재사용성을 위해 기존의 Weapon이라는 클래스를 상속받아 추가 기능을 가지는 또 다른 클래스를 만들고, 각각의 무기를 해당하는 종류의 인터페이스로 또 다시 할당시키는 트리 구조를 만든다는 해결책은 어떨까? 이러면 해당 트리의 WASD() 함수를 모든 무기가 상속받게 될 것이며, 일괄적으로 이동 기능을 부여하거나 수정하는 것도 용이할 것이다.
{{{#!syntax csharp
public class Weapon{
    public virtual void clickL(){ /* 총을 쏜다. */ };
}

public class WeaponNormal : Weapon{
    public virtual void WASD(){ /* 방향키대로 움직인다. */ };
}

public class WeaponRifles : Weapon{
    public virtual void clickR(){ /* 줌 인을 한다. */ }
}

public class Knife : WeaponNormal{
    public override void clickL(){ /* 칼을 휘두른다. */ }
    // 부모 class의 WASD()를 그대로 상속받음.
}

public class Pistol : WeaponNormal{
    public override void clickL(){ /* 권총을 쏜다. */ }
}

public class Snipe : WeaponRifles{
    public override void clickL(){ /* 저격총을 쏜다. */ }
    // 부모 class의 clickR()을 그대로 상속받음.
}
}}}
||<-4> class Weapon ||
||<-2> ▼ ||<-2> ▼ ||
||<-2> class WeaponNormal ||<-2> class WeaponRifles ||
|| ▼ || ▼ ||<-2> ▼ ||
|| class Knife || class Pistol ||<-2> class Snipe ||
|| 좌클릭, 이동 || 좌클릭, 이동 ||<-2> 좌클릭, 우클릭 ||

이러면 문제가 없을까? 그러나 이것도 문제가 있다. 모든 상황에 맞는 class를 일일이 만들어줘야 하다보니, 현재 지정된 class로 해결할 수 없는 새로운 무기가 나오거나 지금 상속된 트리랑 다른 구조를 갖는 방식으로 패치가 된다면 거기에 맞춰 새로운 class를 만들어줘야 한다.

예를 들어 나중에 '칼이 너무 약하니까 칼을 든 상태에서 우클릭하면 강력한 찌르기 공격을 하는 기능을 추가했습니다' 라는 패치를 내놓으면, 지금은 WeaponNormal에 할당된 Knife를 좌클릭, 우클릭, 이동이 다 들어있는 다른 클래스를 만들어 따로 할당시켜줘야 한다. 아니면 WeaponNormal에 좌클릭, 우클릭, 이동을 다 넣어놓고, Pistol을 좌클릭, 이동만 있는 다른 클래스를 만들어 따로 할당시키거나. 게다가 지금은 모든 무기는 좌클릭으로 사용할테니 맨 위에 class Weapon을 넣었지만 나중에 '이건 방패인데요, 좌클릭은 없고 우클릭으로 들기만 할 수 있어요' 라는 문제가 생기면 저 맨 위에 있는 class Weapon마저 수정해야 할 상황이 올 수도 있다.

이렇게 단순히 상속만을 활용하여 새로운 기능을 추가하려고 하면 하나씩 번잡한 문제가 생기고 만다. 전략 패턴은 이런 식으로 같은 행동을 할 때도 다른 행위로 나타나는 상황이 계속 발생하고 추가되고 변경될 수 있는 상황에서 모든 상황에 대한 행위를 담고 있는 '전략'이라는 객체를 만들어 담당시키는 것에 있다.

===== 전략 패턴을 활용한 코딩 =====
이 문제에서 근본적인 문제는 '좌클릭, 우클릭, WASD를 사용하는데 드는 무기에 따라 작동 방식이 다 달라진다' 라는 점에 있다. 그러나 뒤집어 말한다면, '좌클릭, 우클릭, WASD라는 기본적인 틀은 있다' 라는 의미가 된다. 어떤 무기를 들든 해야 할 명령 자체는 정해져있지만 그로 인해 발생하는 행위가 달라진다는 것이다. 따라서 이 때 '전략'이라는 객체가 행해야 할 수단은 이하와 같다.

1. 내가 내릴 수 있는 공통적인 명령의 '''껍데기'''만 인터페이스로 지정한다. 이를 '''캡슐화'''라고 한다.
2. 각각의 명령에 대해서 상황에 따라 취해야 하는 독립적 행동을 지정한다. 이게 '''스트레티지'''가 된다.
3. 그 독립적 행동을 현재 상황에 따라 껍데기 안에서 갈아끼우게만 한다. 이를 '''클라이언트'''라고 한다.

우선 '캡슐화'에 대해서 알아보자. 앞서 이야기했듯 무슨 무기를 들든 해야 할 명령은 정해져있다. 이 모든 것들을 인터페이스로 묶어 하위 개체에서 수정할 수 있도록 함수의 껍데기만 지정한다.
{{{#!syntax csharp
public interface LeftClick{
    public void left();
}

public interface RightClick{
    public void right();
}

public interface WASD{
    public void wasd();
}
}}}
이렇게 껍데기를 지정했다면 각각의 명령이 취할 수 있는 모든 '전략'을 생각해본다. 예를 들어 left키를 누르면 '칼로 벤다, 권총을 쏜다, 저격총을 쏜다'의 3가지 패턴이, right키를 누르면 '줌 인을 한다', '아무 일도 없다'의 2가지, wasd키를 누르면 '움직인다', '움직이지 않는다'의 2가지 패턴이 있을 것이다. 그 모든 패턴 하나하나를 해당 인터페이스의 하위 인터페이스로 작성하고, 각각의 기능을 추가해준다.
{{{#!syntax csharp
public class KnifeLeft : LeftClick{
    public override void left(){ /* 칼로 벤다. */ };
}

public class PistolLeft : LeftClick{
    public override void left(){ /* 권총을 쏜다. */ };
}

public class SnipeLeft : LeftClick{
    public override void left(){ /* 저격총을 쏜다. */ };
}

public class ZoomRight : RightClick{
    public override void right(){ /* 줌 인을 한다. */ };
}

public class NothingRight : RightClick{
    public override void right(){ /* 아무 일도 없다. */ };
}

public class WASDMovable : WASD{
    public override void wasd(){ /* 방향키대로 움직인다. */ };
}

public class WASDUnmovable : WASD{
    public override void wasd(){ /* 움직이지 못한다. */ };
}
}}}
그 다음에 무기를 들었을 때 할 수 있는 모든 행동을 클래스화한다. 그리고 할 수 있는 모든 전략을 내부 변수로 구성하고, 그 행동을 취할 경우 각 전략에서 지정한 함수를 실행하도록 코딩한다.
{{{#!syntax csharp
public class Weapon{
    public LeftClick leftStrategy;
    public RightClick rightStrategy;
    public WASD wasdStrategy;
    
    public void left(){ leftStrategy.left(); }
    public void right(){ rightStrategy.right(); }
    public void wasd(){ wasdStrategy.wasd(); }
}
}}}
이제 만들어진 이 Weapon이 바로 '전략 패턴' 객체가 된다. 앞에서 말한 칼, 권총, 저격총을 이 Weapon을 상속받게 만들고 각각에 해당하는 전략을 할당해준다.
{{{#!syntax csharp
public class Knife : Weapon{
    public Knife(){
        leftStrategy = new KnifeLeft();
        rightStrategy = new NothingRight();
        wasdStrategy = new WASDMovable();
    }
}
public class Pistol : Weapon{
    public Pistol(){
        leftStrategy = new PistolLeft();
        rightStrategy = new NothingRight();
        wasdStrategy = new WASDMovable();
    }
}
public class Snipe : Weapon{
    public Snipe(){
        leftStrategy = new SnipeLeft();
        rightStrategy = new ZoomRight();
        wasdStrategy = new WASDUnmovable();
    }
}
}}}
마지막으로 이 Weapon들을 내부에서 바꿔가면서 실제 left(), right(), wasd() 함수를 실행하는 객체, 즉 플레이어를 클라이언트로 만든다.
{{{#!syntax csharp
public class Player{
    public readonly Knife knife;
    public readonly Pistol pistol;
    public readonly Snipe snipe;

    public Weapon nowWeapon;

    public Player(){
        knife = new Knife();
        pistol = new Pistol();
        snipe = new Snipe();

        nowWeapon = knife;
    }

    public void left(){ nowWeapon.left(); }
    public void right(){ nowWeapon.right(); }
    public void wasd(){ nowWeapon.wasd(); }
}
}}}
이제 nowWeapon을 knife, pistol, snipe로 갈아끼운다고 해도 클라이언트에는 아무 변화도 없이 그냥 nowWeapon에 할당된 함수를 실행한다. 거슬러 올라가면 이 nowWeapon마다 left, right, wasd에 해당하는 전략을 찾아가고, 그 전략 클래스로 거슬러 올라가 지정한 행동을 하게 된다. 예를 들어 이제 nowWeapon에 knife가 들어가있다고 하면 left = leftStrategy.left()를 실행하는데, 그 leftStrategy가 KnifeLeft로 지정되어 있으므로 left() = { /* 칼로 벤다. */ }; 가 실행되는 것이다.

코드를 얼핏 보면 "해결한다고 해놓고 무슨 클래스만 한가득 생기고 몇 단계씩 계속 빙빙 돌게 꼬아놔서 더 복잡해진 거 아니냐?" 라는 소리가 나올 수 있다.

실제로 이 코드 자체는 코드만으로 보면 훨씬 더 복잡해진 것이 맞으나, 유지보수 측면에서 매우 큰 장점을 갖는다. '행동', '전략', '수행'을 각각 다른 클래스로 분할해버렸기 때문에 전략을 바꾸고 싶으면 전략만 수정하면 되고, 행동을 바꾸고 싶다면 행동만 바꾸면 된다. 그렇게 되는 한편으로도 '수행'은 새 무기나 새 행동이 생길 때만 조금씩 수정해주면 된다.

예를 들어서 이 코드에서 '권총이 너무 센 것 같아, 권총을 들면 플레이어가 못 움직이게 만들자' 라고 한다면,
{{{#!syntax csharp
public class Pistol : Weapon{
    public Pistol(){
        leftStrategy = new PistolLeft();
        rightStrategy = new NothingRight();
        //wasdStrategy = new WASDMovable();
        wasdStrategy = new WASDUnmovable();
    }
}
}}}
이런 방식으로 상속을 따로 건드릴 필요 없이 그냥 Pistol에 할당된 wasdStrategy만 바꿔버리면 해결된다. 그러다가 '이러니까 권총이 너무 약하네, 그럼 타협해서 권총을 들면 움직일 순 있어도 느리게 움직이게 만들자' 라는 패치를 할 경우에도,
{{{#!syntax csharp
public class WASDSlowmovable : WASD{
    public override void wasd(){ /* 방향키대로 많이 느리게 움직인다. */ };
}

public class Pistol : Weapon{
    public Pistol(){
        leftStrategy = new PistolLeft();
        rightStrategy = new NothingRight();
        //wasdStrategy = new WASDUnmovable();
        wasdStrategy = new WASDSlowmovable();
    }
}
}}}
느리게 움직이는 WASD 전략을 하나 더 만들어주고 Pistol의 wasdStrategy를 바꿔주면 된다.

반대로 이런 개개인의 처리가 아니라 '플레이어가 너무 빠르니 전반적인 이동 속도를 느리게 하자' 같은 경우,
{{{#!syntax csharp
public class WASDMovable : WASD{
    //public override void wasd(){ /* 방향키대로 움직인다. */ };
    public override void wasd(){ /* 방향키대로 움직이는데, 좀 느린 속도로. */ };
}
}}}
일괄적으로 행해지는 행동 부분을 수정하면 WASDMovable 전략을 쓰는 모든 무기가 영향을 받으므로 일괄 수정도 간단하다. 물론 앞에서 말한 Slowmovable 같은 건 또 따로 수정해줘야 하겠지만, 그걸 사용하지 않는 추후 수정되는 무기들은 일괄적으로 느려진 이동속도 전략을 상속받게 될 것이다. 게다가 이런 식으로 만들어놓고 나중에 '새로운 무기인 방패. 좌클릭은 기능 없음, 우클릭을 들면 방패를 듦. 장비하면 느린 속도로 이동함' 같은 패치를 할 때도,

{{{#!syntax csharp
public class NothingLeft : LeftClick{
    public override void left(){ /* 아무 일도 일어나지 않는다. */ }; // 좌클릭이 기능하지 않는 새 전략
}

public class DefenceRight : RightClick{
    public override void right(){ /* 방패를 들어 전방의 공격을 막는다. */ };  // 우클릭으로 방어하는 새 전략
}

public class Shield : Weapon{
    public Shield(){ // 새로운 무기인 방패의 class
        leftStrategy = new NothingLeft();
        rightStrategy = new DefenceRight(); // 방패에 맞는 새 좌클릭, 우클릭 전략 배정
        wasdStrategy = new WASDSlowmovable(); // 이미 쓰던 전략을 재탕
    }
}

public class Player{
    public readonly Knife knife;
    public readonly Pistol pistol;
    public readonly Snipe snipe;
    public readonly Shield shield; // 클라이언트에 방패 추가해주고

    public Weapon nowWeapon;

    public Player(){
        knife = new Knife();
        pistol = new Pistol();
        snipe = new Snipe();
        shield = new Shield(); // 선언만 해주면 끝.

        nowWeapon = knife;
    }

    public void left(){ nowWeapon.left(); }
    public void right(){ nowWeapon.right(); }
    public void wasd(){ nowWeapon.wasd(); }
}
}}}
물론 전략 패턴이 만능인 것은 아니다. 이 경우에도 만약 좌클릭, 우클릭, WASD 외에 R키, Q키 같은 새로운 키가 생겨나기 시작하면 그 키마다 새로운 전략을 생성하고 기존에 있는 무기에도 새로운 키에 맞는 전략을 배정해줘야 하며, 클라이언트에서도 해당 전략을 통한 함수를 추가해줘야 하기 때문이다. 이는 앞서 말한 첫 번째 예시에서 보이듯이 더미 함수를 계속 추가시키는 것과 얼핏 보면 다를 게 없어보인다.

그러나 이 경우에도 전략 패턴은 첫 번째 예시보다 더욱 간편하다. 첫 번째 예시에서는 더미 함수를 '''해당 키를 사용하지 않는 모든 무기'''에 대해, '''아무 일도 일어나지 않음'''이라는 똑같은 함수를 일일이 배정해줘야 하기 때문이다. 배정하다가 실수가 생길 수 있고, 나중에 '고심 끝에 모든 무기에 줌을 넣기로 했음' 같은 패치가 생겼다간 지정해주었던 더미 함수를 모조리 수정해야 하는 참사가 생길 수도 있다. 그러나 전략 패턴을 사용할 경우, '''해당 키를 사용하지 않는 모든 무기'''에 일일이 배정해줘야 하는 것은 같아도, '''아무 일도 일어나지 않는다는 전략 하나'''만 만들고 그걸로 죄 다 할당시켜주면 되기 때문에 간편하다. 예를 들어 나중에 R키를 사용하는 무기가 생긴다면,
{{{#!syntax csharp
public interface RClick{
    public void keyboardr(); // R키를 눌러서 발생하는 인터페이스 캡슐화
}

public class NothingR : RClick{
    public override keyboardr(){ /* 아무 일도 일어나지 않음. */ } // 미작동한다는 전략 생성
}

public class Weapon{
    public LeftClick leftStrategy;
    public RightClick rightStrategy;
    public WASD wasdStrategy;
    public RClick rStrategy; // R키를 눌렀을 때의 전략 생성
    
    public void left(){ leftStrategy.left(); }
    public void right(){ rightStrategy.right(); }
    public void wasd(){ wasdStrategy.wasd(); }
    public void keyboardr(){ rStrategy.keyboardr(); } // 전략을 따라가도록 함수 배정
}

public class Knife : Weapon{
    public Knife(){
        leftStrategy = new KnifeLeft();
        rightStrategy = new NothingRight();
        wasdStrategy = new WASDMovable();
        rStrategy = new NothingR(); // 해당 기능을 안 쓰는 무기에 대해서는 아무 것도 안 하는 전략 배정
    }
}

public class Player{
    public readonly Knife knife;
    public readonly Pistol pistol;
    public readonly Snipe snipe;
    public readonly Shield shield;

    public Weapon nowWeapon;

    public Player(){
        knife = new Knife();
        pistol = new Pistol();
        snipe = new Snipe();
        shield = new Shield();

        nowWeapon = knife;
    }

    public void left(){ nowWeapon.left(); }
    public void right(){ nowWeapon.right(); }
    public void wasd(){ nowWeapon.wasd(); }
    public void keyboardr(){ nowWeapon.keyboardr(); } // 클라이언트에서 R키에 반응하는 함수 지정.
}
}}}
하는 식으로 비교적 간단하게 새로운 키를 배정시킬 수 있다.
